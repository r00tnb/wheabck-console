r'''Exec a system command on server.

执行服务端系统命令

'''

from api.exploit import WebshellExploit, Cmdline
from api.webshell import WebshellSession, Webshell, CommandExecutor
from api import Session, utils, logger, colour
from .shell.by_namedpipe import NamedpipeUnixShell
from .shell.base import BaseShell, NormalShell
from .cmd import PHPCmd, CSharpCmd
import argparse
import json
import base64
import threading

class exploit(WebshellExploit, CommandExecutor):
    
    def __init__(self):
        super().__init__()
        self.parse = argparse.ArgumentParser(prog='exec', description="Exec a command on server system.", 
            epilog="If you want to exec a command line that contains spaces, you need to use quotation marks.")
        self.parse.add_argument('command', nargs='?', default='', help="A command expression.")
        self.parse.add_argument("-e", "--raw-executor", help="Specifies that this parameter will not be affected by `command_ Executor` webshell option.", 
            action="store_true")
        interact_group = self.parse.add_argument_group("interactive shell options")
        interact_group.add_argument('-i', "--interactive", help="Specify an interactive shell.Like `sh -i 2>&1`", nargs='?', const='ok')
        interact_group.add_argument("-t", "--type", help="Specify what method to use to establish an interactive shell.\
            Like base(Basic shell, unable to maintain state), normal(Use files to maintain interaction with the shell, which has the usual meaning of interactive) and \
            namedpipe(Use named pipes to maintain interaction with the shell, which has the usual meaning of interactive, only on unix)", choices=["normal", "base", "namedpipe"])

        self.help = __doc__+self.parse.format_help()

        self.executor = None

    def run(self, args: Cmdline)-> int:
        args = self.parse.parse_args(args.options)
        if args.interactive:
            self.interactive(args.interactive, args.type)
        elif args.show_methods:
            self.show_methods()
        elif args.executor_method:
            self.executor.method = args.executor_method
            self.show_methods()
        elif args.command == '':
            logger.warning("You entered an empty command!")
        else:
            self.exec(args.command, args.raw_executor)

        return self.SUCCESS

    def show_methods(self):
        print("Cuurent Method: ", self.executor.method)
        ok = list(self.executor.available_methods)
        for i in range(len(ok)):
            if self.executor.method == ok[i]:
                ok[i] = colour.colorize(ok[i], ['bold', 'invert'])
        print("All Methods: ", '|'.join(ok))
    
    def support(self, session:WebshellSession)-> bool:
        '''判断当前命令是否支持指定的session， 一般来说session即为运行改命令时的session
        '''
        self.session = session
        if isinstance(self.session, WebshellSession):
            # 初始化session相关参数
            if self.session.state['lang'] == Webshell.PHP:
                self.executor = PHPCmd(self, 'auto')
            elif self.session.state['lang'] == Webshell.ASP_NET_CS:
                self.executor = CSharpCmd(self, 'shell')

            if self.executor:# 添加一些依赖executor的参数
                setting_group = self.parse.add_argument_group("exector options")
                setting_group.add_argument("-s", "--show-methods", help="Displays the method of executing the current command.", action="store_true")
                setting_group.add_argument("-m", "--executor-method", 
                    help="Sets how the command executor executes the command.\nPHP: exec,passthru, popen, proc_open, shell_exec, wscript, auto(It will automatically find the appropriate command execution function).\n\
                    ASP.NET: shell, process", 
                    choices=self.executor.available_methods)

            return True

        return False

    def exec_command_on_server(self, cmd:str)->str:
        if self.executor:
            return self.executor.exec(cmd)
        return None

    def exec(self, command: str, raw:bool):
        result = None
        if raw:
            result = self.exec_command_on_server(command)
        else:
            result = self.exec_command(command)
        if result is not None:
            print(result)
        else:
            logger.error(f"Command `{cmd}` exec failed!")

    def interactive(self, shell: str, type: str):
        if shell == "ok":
            if 'win' in self.session.server_info['os_type'].lower():
                shell = "cmd 2>&1"
            else:
                shell = "sh -i 2>&1"
        interact_shell = BaseShell(self)
        if type is None:
            type = "base"
        if type == "normal":
            interact_shell = NormalShell(self, shell)
        elif type == "namedpipe":
            if 'win' in self.session.server_info['os_type'].lower():
                logger.warning("Windows system has not yet implemented interactive shell execution through named pipes!")
                logger.info("The same effect can be achieved by using `normal` type")
                return
            else:
                interact_shell = NamedpipeUnixShell(self, shell)

        interact_shell.cmdloop()
    
    def hook_loaded(self):
        m = self.load_config('exec-config')
        if self.executor and m:
            self.executor.method = m.get('method')
    
    def hook_destroy(self):
        if self.executor:
            self.save_config('exec-config', {'method':self.executor.method})