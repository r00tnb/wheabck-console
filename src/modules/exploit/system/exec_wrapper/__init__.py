r'''Execute packaged commands.

'''

from api.exploit import WebshellExploit, Cmdline
from api.webshell import WebshellSession, CommandExecutor
from api import Session, logger, tablor, utils
import argparse
import base64

class exploit(WebshellExploit, CommandExecutor):
    
    def __init__(self):
        super().__init__()
        self.parse = argparse.ArgumentParser(prog='exec_wrapper', description="Execute packaged commands.")
        self.parse.add_argument('cmd', help="A command will be inserted into the package(Command execution will not be affected by the command_executor option)", nargs='?', default=None)
        self.parse.add_argument('-f', '--format', help="Set the packaging format of the command and use ${cmd} instead of the incoming command")
        self.parse.add_argument('-s', '--show', help="Display current settings.", action='store_true')
        self.parse.add_argument('-v', '--verbose', help="Set if display the final command line executed on the server every time a command is executed.", choices=['true', 'false'])
        self.parse.add_argument('-c', '--code', help="Set the python code used to process the incoming command (the incoming command is stored in the cmd variable).")
        self.help = __doc__+self.parse.format_help()

        self.format = '${cmd}'
        self.exec_type = None
        self.code = None
        self.verbose = False

    def exec_command_on_server(self, cmd: str)-> str:
        if self.code:
            a = {'cmd':cmd}
            exec(self.code, globals(), a)
            cmd = a.get('cmd')
        cmd = utils.templete_0(self.format, cmd=cmd)
        if self.verbose:
            logger.info(cmd)
        if self.exec_type:
            return self.exec_type.exec_command_on_server(cmd)
        return None

    def run(self, args: Cmdline)-> int:
        args = self.parse.parse_args(args.options)
        if args.format:
            self.format = args.format
            logger.info("Update command format successful!")
        if args.code:
            self.code = args.code
            logger.info("Update command handle code successful!")
        if args.exec_type:
            self.exec_type = self.session.command_map.get(args.exec_type)
            logger.info("Update command execute type successful!")
        if args.verbose:
            self.verbose = True if args.verbose=='true' else False
            logger.info("Update verbose successful!")
        if args.show:
            info = []
            info.append(['Format', self.format])
            info.append(['Executor', self.exec_type.name])
            info.append(['Handle Code', self.code])
            info.append(['verbose', self.verbose])
            print(tablor(info, header=False, max_width="100-2"))
        elif args.cmd:
            print(self.exec_command_on_server(args.cmd))

        return self.SUCCESS

    def hook_destroy(self):
        self.save_config('exec_wrapper-config', {
            'format':self.format,
            'exec_type':self.exec_type.name,
            'code':self.code,
            'verbose':self.verbose
        })

    def hook_loaded(self):
        # 添加新选项
        choice = []
        for n, e in self.session.command_map.items():
            if isinstance(e, CommandExecutor) and e is not self:
                choice.append(n)
        self.parse.add_argument('-t', '--exec-type', help="Set the name of the command executor currently used for command execution.", choices=choice)

        config = self.load_config('exec_wrapper-config')
        if not config:
            config = {}
        self.format = config.get('format', '${cmd}')
        self.exec_type = self.session.command_map.get(config.get('exec_type', 'exec'))
        self.code = config.get('code')
        self.verbose = config.get('verbose', False)