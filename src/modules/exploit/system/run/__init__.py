r'''Run a system command on server.

执行服务端系统命令

'''

from api.exploit import WebshellExploit, Cmdline
from api.webshell import WebshellSession, Webshell
from api import Session, utils, logger
from .shell.by_namedpipe import NamedpipeUnixShell
from .shell.base import BaseShell, NormalShell
import argparse
import json
import base64
import threading

class exploit(WebshellExploit):
    
    def __init__(self):
        super().__init__()
        self.parse = argparse.ArgumentParser(prog='run', description="Run a command on server system.", 
            epilog="If you want to run a command line that contains spaces, you need to use quotation marks.")
        self.parse.add_argument('command', nargs='?', default='', help="A command expression.")
        interact_group = self.parse.add_argument_group("interactive shell options")
        interact_group.add_argument('-i', "--interactive", help="Specify an interactive shell.Like `sh -i 2>&1`", nargs='?', const='ok')
        interact_group.add_argument("-t", "--type", help="Specify what method to use to establish an interactive shell.\
            Like base(Basic shell, unable to maintain state), normal(Use files to maintain interaction with the shell, which has the usual meaning of interactive) and \
            namedpipe(Use named pipes to maintain interaction with the shell, which has the usual meaning of interactive)", choices=["normal", "base", "namedpipe"])

        self.help = __doc__+self.parse.format_help()

    def run(self, args: Cmdline)-> int:
        args = self.parse.parse_args(args.options)
        if args.interactive:
            self.interactive(args.interactive, args.type)
        elif args.command == '':
            logger.warning("You entered an empty command!")
        else:
            self.exec(args.command)

        return self.SUCCESS
    
    def support(self, session:WebshellSession)-> bool:
        '''判断当前命令是否支持指定的session， 一般来说session即为运行改命令时的session
        '''
        self.session = session
        return isinstance(self.session, WebshellSession)

    def exec(self, command: str):
        cmd = self.exec_command(command)
        if cmd is not None:
            print(cmd.decode(self.session.client.options.encoding, 'ignore'))

    def interactive(self, shell: str, type: str):
        if shell == "ok":
            if 'win' in self.session.server_info['os_type'].lower():
                shell = "cmd 2>&1"
            else:
                shell = "sh -i 2>&1"
        interact_shell = BaseShell(self)
        if type is None:
            type = "base"
        if type == "normal":
            interact_shell = NormalShell(self, shell)
        elif type == "namedpipe":
            if 'win' in self.session.server_info['os_type'].lower():
                logger.warning("Windows system has not yet implemented interactive shell execution through named pipes!")
                logger.info("The same effect can be achieved by using `normal` type")
                return
            else:
                interact_shell = NamedpipeUnixShell(self, shell)

        interact_shell.cmdloop()
    