r'''Generate the specified webshell.
'''

from api.exploit import Exploit, Cmdline
from api.webshell import Webshell
from api import MainSession, config, load_module, colour, logger
import argparse
import re
import os

class exploit(Exploit):

    manager = None

    def __init__(self):
        self.parse = argparse.ArgumentParser(prog='generate', description='Generate the specified webshell.')
        self.parse.add_argument('webshell', 
            help="A webshell client like `php/sample_one_word`.If this option is not specified and a webshell client has been loaded in the current session, the current webshell client will be used to generate code. At this time, the `-o` option is invalid", 
            type=self._check, nargs='?', default=None)
        self.parse.add_argument('-o', '--options', nargs='*',
            help='Pass parameters to the specified webshell. This parameter is the parameter of the corresponding client.like `-o password=c`')
        self.parse.add_argument('-f', '--filepath', help="Specify the path to save the webshell.")
        self.help = __doc__ + self.parse.format_help()
    
    def _check(self, param: str)-> str:
        test = r'[\w\-/]+'
        if re.fullmatch(test, param):
            return param
        
        raise TypeError(f'Webshell client like `{test}`')

    def support(self, session)-> bool:
        '''判断当前命令是否支持指定的session， 一般来说session即为运行改命令时的session
        '''
        self.session = session
        if isinstance(self.session, MainSession):
            exploit.manager = self.session # 保存当前的主session实例
        return True

    def _show_code(self, client:Webshell, code: bytes, filepath: str)-> int:
        if filepath:
            try:
                with open(os.path.join(config.work_path, filepath), 'wb') as f:
                    f.write(code)
                    logger.info(f"Webshell has been written to the file `{os.path.join(config.work_path, filepath)}`", True)
            except OSError as e:
                logger.error(e)
                return self.STOP
        else:
            print(code.decode(errors='ignore'))
        return self.SUCCESS

    def run(self, args: Cmdline)-> int:
        args = self.parse.parse_args(args.options)
        webshell = args.webshell
        if webshell is None:
            webshell = self.session.client
            if webshell is None:
                logger.error('No webshell is specified!')
                return self.STOP
        else:
            if self.manager.exec(['use', webshell]) == self.STOP:
                return self.STOP
            webshell = self.manager.client
            if args.options:
                for o in args.option:
                    o = o.split('=')
                    if self.manager.exec(['set',o[0], o[1:2][0]]) == self.STOP:
                        return self.STOP
        return self._show_code(webshell, webshell.generate(), args.filepath)

    def docomplete(self, text: str)-> dict:
        result = []
        pre = ''
        match = re.compile(r'^(generate +)([\w\-/\\]*)$', re.M).search(text)
        if match:
            tmp = self.manager.modules.get('webshell')
            k = ''
            s = ''
            for k in match.group(2).split('/'):
                if k not in tmp:
                    break
                tmp = tmp[k]
                s = os.path.join(s, k)
            pre = match.group(1)+os.path.join(s, 'a')[:-1]
            pre = pre.replace(os.sep, '/')
            if isinstance(tmp, dict):
                for key in tmp:
                    if key.startswith(k):
                        if isinstance(tmp[key], dict):
                            key += '/'
                        else:
                            key += ' '
                        result.append(key)

        return {'pre':pre, 'matchs':result}