r'''Create an alias for command.
'''
from api.exploit import Exploit, Cmdline, WebshellExploit
from api.webshell import WebshellSession
from api import logger, config, utils
import argparse
import re

class AliasCommand(Exploit):
    '''
    __init__:
        name        指定命令的别名
        value       别名对应的实际命令对象
    '''
    def __init__(self, name: str, value: str, params: list, help: str, session):
        super().__init__()
        self.name = name
        self.value = value
        self.params = params
        self.session = session
        self.help = help

    def run(self, args:Cmdline)-> int:
        params = [[p, ''] for p in self.params]
        options = list(args.options)
        for i in range(len(params)):
            if options:
                params[i][1] = options[0]
                del options[0]
        params = dict(params)
        v = utils.templete_0(self.value, **params)
        args = Cmdline((args.cmd, *options)).cmdline.replace(args.cmd, v)
        return self.session.exec(args)

class exploit(WebshellExploit):
    def __init__(self):
        self.parse = argparse.ArgumentParser(prog='alias', description='Create alias for command.')
        self.parse.add_argument('-D', '--description', help="A description for alias.")
        self.parse.add_argument('-p', '--param', help="Specify positional parameters, the first few positional parameters of the command alias will be filled in the specified position in turn.", 
            nargs='+')
        self.parse.add_argument('alias', help="A alias for cmd", type=self._check)
        self.parse.add_argument('cmd', help="A command name or expression", nargs="*")
        self.help = __doc__ + self.parse.format_help()

    def _check(self, param: str):
        '''检查传入参数是否合法
        '''
        test = r'[\w\-]+'
        if re.fullmatch(test, param):
            return param
        raise TypeError(f"Options must be fullmatch by regexp `{test}`.")

    def support(self, session)-> bool:
        '''判断当前命令是否支持指定的session， 一般来说session即为运行改命令时的session
        '''
        self.session = session
        return True

    def run(self, args: Cmdline)-> int:
        args = self.parse.parse_args(args.options)
        if self.session.has_cmd(args.alias) and utils.input("Alias ​​already exists!Do you want to overwrite it? (y/n) ").lower() != 'y':
            return self.STOP
        cmd = [] if args.cmd is None else args.cmd
        cmd = ' '.join(cmd)
        self._add(args.alias, cmd, args.description, args.param)
        logger.info(f"Add alias command: {args.alias} => {cmd}", True)
        return self.SUCCESS

    def _add(self, name: str, value: str, des: str=None, params: list=None):
        self.session.alias_command[name] = AliasCommand(name, value,  params if params else [], 
            des if des else f"{name} => {value}", self.session)

    def docomplete(self, text: str)-> dict: # alias命令补全
        result = []
        pre = ''
        match = re.compile(r'^(alias(?: -D .*?)? [\w\-]* )([\w\-]*)$', re.M).search(text)
        if match:
            pre = match.group(1)
            for cmd in self.session.command_map:
                if cmd.startswith(match.group(2).lower()):
                    result.append(cmd+' ')

        return {'pre':pre, 'matchs':result}

    def hook_loaded(self):
        # 常用别名定义
        self._add('lls', f"lrun {'dir' if 'win' in config.platform else 'ls'}", "List local files")
        if isinstance(self.session, WebshellSession):
            self._add('bg', "sessions -i 0", "Background current session and switch to main session.")

        # 从配置文件中恢复保存的别名
        alias_list = self.load_config('alias-config')
        if alias_list is not None:
            for a in alias_list:
                self._add(*a)

    def hook_destroy(self):
        if isinstance(self.session, WebshellSession):
            alias_list = []
            for name, cmd in self.session.alias_command.items():
                alias_list.append((name, cmd.value, cmd.help, cmd.params))
            self.save_config('alias-config', alias_list)
