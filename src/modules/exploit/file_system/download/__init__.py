r'''Download file or folder on server to local.
'''

from api.exploit import WebshellExploit, Cmdline
from api.webshell import WebshellSession, Webshell
from api import logger, config, utils, colour
import argparse
import base64
import tempfile
import os
import json

class exploit(WebshellExploit):

    def __init__(self):
        super().__init__()
        self.parse = argparse.ArgumentParser(prog="download", description="Download file or folder on server to local.")
        self.parse.add_argument('source', help="A file path to download on server.")
        self.parse.add_argument('local', help="A file path to save on local.", nargs='?', default=None)
        self.parse.add_argument('-r', '--recursive', action='store_true', help="If you are downloading a directory, you need to specify this option")
        self.help = __doc__ + self.parse.format_help()

    def support(self, session:WebshellSession)-> bool:
        '''判断当前命令是否支持指定的session， 一般来说session即为运行改命令时的session
        '''
        self.session = session
        return isinstance(self.session, WebshellSession) and self.session.server_info.lang in (Webshell.PHP, Webshell.ASP_NET_CS, )

    def run(self, args:Cmdline)-> int:
        args = self.parse.parse_args(args.options)
        local = args.local
        if local is None:
            local = utils.pathsplit(args.source)[1]
        local = local.replace('/', os.sep)
        local = os.path.join(config.work_path, local)
        d, fname = utils.pathsplit(args.source)
        if os.path.exists(local):
            if os.path.isfile(local):
                logger.warning(f"Local file `{local}` is exist.")
                if utils.input(colour.colorize("Are you sure to overwrite it?(y/n) ", 'bold')).lower() != 'y':
                    return self.STOP
            elif os.path.isdir(local): # 如果指定的本地路径为目录，那么会把下载的文件或目录放在该目录下
                for f in os.listdir(local):
                    if f.lower() == fname.lower():
                        if os.path.isdir(f):# 不准有同名目录
                            logger.error(f"Local folder `{local}` contain a same name directory `{f}`!")
                            return self.STOP
                        logger.warning(f"Local folder `{local}` contain a same name file `{fname}`.")
                        if utils.input(colour.colorize("Are you sure to overwrite it?(y/n) ", 'bold')).lower() != 'y':
                            return self.STOP
                        break
        else:
            dirname = os.path.dirname(local.rstrip(os.sep))
            if not os.path.exists(dirname):
                logger.error(f"Local directory `{dirname}` is not exist!")
                return self.STOP
        logger.info("Downloading...")
        ret = self.download(args.source, local, args.recursive)
        if ret == self.SUCCESS:
            logger.info("All items downloaded!")
        return ret

    def download(self, server_path: str, local_path: str, r: bool)-> int:
        ret = self.evalfile('download', pwd=self.session.pwd, path=server_path)
        ret = ret.data
        if ret is None:
            logger.error(f"Download {server_path} failed!")
            return self.STOP
        ret = json.loads(ret)
        if ret['code'] == 1:
            with open(local_path, 'wb') as f:
                data = base64.b64decode(ret['msg'].encode())
                f.write(data)
            logger.info(f'Download a file `{server_path}` success!', True)
            return self.SUCCESS
        elif ret['code'] == 2:
            logger.error(f"Server file `{server_path}` is not readable!Check your permissions.")
        elif ret['code'] == 0:
            logger.error(f"Server file `{server_path}` is not exist!")
        elif ret['code'] == -2:
            logger.error(f"Server file `{server_path}` is an unknown file type!")
        elif ret['code'] == -1:
            logger.error(f"Server file `{server_path}` is a directory, but not readable!")
        elif ret['code'] == -3:
            if r:# 递归的下载目录
                sep = ret['msg']
                if not os.path.exists(local_path):
                    os.mkdir(local_path)
                ret = self.evalfile('listdir', path=server_path, pwd=self.session.pwd)
                ret = ret.data
                if ret is None:
                    logger.error(f"List dir `{server_path}` failed!Download failed!")
                    return self.STOP
                ret = json.loads(ret)
                if ret['code'] == 1:
                    l = ret['list']
                    logger.info(f'Downloading directory `{server_path}`...')
                    for fname in l:
                        fname = base64.b64decode(fname.encode()).decode(self.session.client.options.encoding, 'ignore')
                        self.download(server_path+sep+fname, os.path.join(local_path, fname), r)
                    return self.SUCCESS
                else:
                    logger.error("Download error!") 
            else:
                logger.error(f"Server file `{server_path}` is a directory.")
                logger.error("If you want to download directories recursively, you must specify the `-r` option.")
        
        return self.STOP

        