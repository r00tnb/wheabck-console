r'''Port forwarding by HTTP tunnel.

'''
from api.exploit import WebshellExploit, Cmdline
from api.webshell import WebshellSession, Webshell
from api import Session, logger, utils, tablor, colour
from .forward import Forward
from .reverse import ForwardReverse
import argparse
import re

class exploit(WebshellExploit):
    
    def __init__(self):
        super().__init__()
        self.parse = argparse.ArgumentParser(prog='portfwd', description="Port forwarding by HTTP tunnel")
        operate_group = self.parse.add_mutually_exclusive_group()
        operate_group.add_argument('--add', help="Add a forwarding rule.", action='store_true')
        operate_group.add_argument('--list', help="List all forwarding rules.", action='store_true')
        operate_group.add_argument('--flush', help="Refresh the specified forwarding connection by id.", nargs='+', type=int)
        operate_group.add_argument('--delete', help="Delete the specified forwarding rule by id.", nargs='+', type=int)
        config_group = self.parse.add_argument_group("Config options")
        config_group.add_argument('-l', '--lhost', help="Specify a local address.", default='127.0.0.1')
        config_group.add_argument('-p', '--lport', help="Specify a local port.", type=int)
        config_group.add_argument('-R', help="Indicates that the local port will be forwarded to the remote.", action='store_true')
        config_group.add_argument('-L', help="Indicates that the remote port will be forwarded to the local.", action='store_true')
        config_group.add_argument('-r', '--rhost', help="Specify a remote address.", default="127.0.0.1")
        config_group.add_argument('-P', '--rport', help="Specify a remote port.", type=int)
        config_group.add_argument('-s', '--uploadsize', help="Set the data size limit for each upload.You can use k, m, etc. to set the size, setting 0 will not limit the size of the data uploaded each time.Such as 1024, 1024b, 1024k, etc. are all valid", 
            type=self._getsize, default="0")
        self.help = __doc__+self.parse.format_help()

        self._forward_list = {} # 格式类似{1:{}, 2:{}}

    def _getsize(self, size: str)-> int:
        '''用于转换传入的--uploadsize参数
        '''
        size = size.strip().rstrip('bB').lower()
        try:
            util = size[-1]
            if util not in 'km':
                return int(size)

            size = float(size[:-1])
            if util == 'k':
                size *= 1024
            elif util == 'm':
                size *= 1024*1024
            return int(size)
        except Exception as e:
            logger.error("Upload size parameter format error!(You can set like 1024, 1232k, 2131M, 0 etc.)")
            raise e

    def support(self, session:WebshellSession)-> bool:
        '''判断当前命令是否支持指定的session， 一般来说session即为运行该命令时的session
        '''
        self.session = session
        return isinstance(self.session, WebshellSession) and self.session.state['lang'] in (Webshell.PHP, Webshell.ASP_NET_CS, )

    def run(self, args: Cmdline)-> int:
        args = self.parse.parse_args(args.options)
        ret = self.SUCCESS
        if args.add:
            lhost = args.lhost if args.lhost else None
            lport = args.lport if args.lport else None
            rhost = args.rhost if args.rhost else None
            rport = args.rport if args.rport else None
            lf = True if args.L else (False if args.R else None)
            uploadsize = args.uploadsize
            info = (lhost, lport, rhost, rport, lf, uploadsize)
            if None in info:
                logger.error("Some options are not set.Check you input.")
                return self.STOP
            ret = self._add(*info)
        elif args.flush:
            for ID in args.flush:
                rule = self._forward_list.get(ID)
                if rule:
                    self._flush(ID)
                else:
                    logger.warning(f"No specified rules `{ID}`!")
        elif args.delete:
            self._delete(args.delete)
        else:
            ret = self._list()
        return ret

    def _list(self):
        table = [['ID', 'Forwarding Rule', 'Upload limit', 'Alive Connections Count', 'State']]
        for ID, rule in self._forward_list.items():
            tmp = []
            tmp.append(ID)
            tmp.append(f"{rule['lhost']}:{rule['lport']} {'<=' if rule['lf'] else '=>'} {rule['rhost']}:{rule['rport']}")
            tmp.append(f"{'Unlimited' if rule['uploadsize'] == 0 else rule['uploadsize']}")
            cc = 0
            if rule['forwd']:
                if rule['lf']:
                    cc = len(rule['forwd'].connections)
                else:
                    if rule['forwd'].is_alive() and rule['forwd'].connections and list(rule['forwd'].connections.values())[0]:
                        cc = 1
            tmp.append(cc)
            state = colour.colorize('Stopped', 'bold', 'red')
            if rule['forwd'] and rule['forwd'].is_alive():
                state = colour.colorize('Running', 'bold', 'green')
            tmp.append(state)
            table.append(tmp)
        print(tablor(table, border=False, title="Forwarding Rule Table", aligning="right-3"))
        return self.SUCCESS

    def _delete(self, id_list: list):
        if not id_list:
            return
        logger.info("Deleting the specified forwarding rules...")
        for ID in id_list:
            rule = self._forward_list.get(ID)
            if rule:
                if rule['forwd']:
                    rule['forwd'].close()
                self._forward_list.pop(ID)
                logger.info(f"Delete a forward rule `{ID}`", False)
            else:
                logger.warning(f"No specified rules `{ID}`!")

    def _add(self, lhost:str, lport:int, rhost: str, rport: int, lf: bool, uploadsize: int)-> int:
        '''添加转发规则，lf指定是否是正向转发（将远程端口转发到本地，使得可以通过访问本地端口间接访问到远程端口）
        '''
        ID = 0 if len(self._forward_list)==0 else (max(self._forward_list)+1)
        self._forward_list[ID]={
            'lhost':lhost, 'lport':lport, 'rhost':rhost, 'rport':rport, 'lf':lf, "forwd":None, "uploadsize": uploadsize
        } # 最后一个元素表示该规则对应的转发实例
        if self.SUCCESS == self._flush(ID):
            logger.info(f"Add a forwarding rule: {lhost}:{lport} {'<=' if lf else '=>'} {rhost}:{rport}", True)
            return self.SUCCESS
        else:
            logger.error("Add forwarding rule failed!")

        return self.STOP

    def _flush(self, ID: int)-> int:
        '''建立或更新端口转发
        '''
        rule = self._forward_list.get(ID)
        myforward = Forward if rule['lf'] else ForwardReverse
        if rule['forwd'] is None:
            forwd = myforward(rule['lhost'], rule['lport'], rule['rhost'], rule['rport'], rule['uploadsize'], self)
            rule['forwd'] = forwd
            forwd.setDaemon(True)
            forwd.start()
        else:
            logger.info(f"Refreshing the forwarding rule `{ID}`...")
            forwd = rule['forwd']
            if forwd.is_alive():
                forwd.close()
            forwd = myforward(rule['lhost'], rule['lport'], rule['rhost'], rule['rport'], rule['uploadsize'], self)
            rule['forwd'] = forwd
            forwd.setDaemon(True)
            forwd.start()
            logger.info("Refreshed over!")
        return self.SUCCESS

    def docomplete(self, text: str)-> dict:
        result = {'pre':'', 'matchs':[]}
        match = re.fullmatch(r'(portfwd +)([\w\-]*)', text)
        if match:
            result['pre'] = match.group(1)
            for key in ['--flush', '--delete', '--add', '--list']:
                if key.startswith(match.group(2).lower()):
                    result['matchs'].append(key+' ')
        return result

    def hook_destroy(self):
        self._delete(list(self._forward_list.keys()))