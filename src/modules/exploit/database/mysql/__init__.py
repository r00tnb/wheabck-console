r'''Mysql client.

'''

from api.exploit import WebshellExploit, Cmdline
from api.webshell import WebshellSession, Webshell, CSharpWebshell, EvalResult
from api import Session, utils, logger, tablor, colour
import argparse
import json
import base64
import re
import os
from functools import wraps


def upload_library_on_failed(func):
    '''当函数执行失败时，像服务器上传可能缺少的库文件
    '''
    @wraps(func)
    def wrappers(self, *args, **kw):
        ret = func(self, *args, **kw)
        if ret != self.SUCCESS:
            if isinstance(self.session.client, CSharpWebshell):
                logger.info("Try to upload MySql.Data.dll !")
                path = self.session.server_info['tmpdir']+self.session.server_info['sep']+utils.randomstr(8)+'.dll'
                self.session.exec(['upload', os.path.join(os.path.dirname(__file__), 'extra_code', 'MySql.Data.dll'), path])
                self.session.client.options.set_temp_option('extra_assemblys', f"['System.Data.dll', '{path}']")
                return func(self, *args, **kw)
        return ret
    return wrappers

class exploit(WebshellExploit):
    
    def __init__(self):
        super().__init__()
        self.parse = argparse.ArgumentParser(prog='mysql', description="Mysql client.", 
            epilog="Before executing the SQL statement, you must first establish a connection.")

        query_group = self.parse.add_argument_group('Query options')
        query_group.add_argument('-i', '--interactive', action='store_true', help="Enter the interactive mode to execute SQL statements continuously")
        query_group.add_argument('sql', nargs='?', default=None, help="A SQL statement.")

        state_group = self.parse.add_argument_group('Set status options')
        state_group.add_argument('-c', "--connect", help="Perform connection test.", action='store_true')
        state_group.add_argument('-H', '--host', help="Specify the host name.")
        state_group.add_argument('-P', '--port', help="Specify the host port.")
        state_group.add_argument('-u', '--user', help="Specify the database user name.")
        state_group.add_argument('-p', '--password', help="Specify the database connection password.Do not specify a value to blank.", nargs='?', const=True)
        state_group.add_argument('-d', '--database', help="Specify the name of the current database.Do not specify a value to blank.", nargs='?', const=True)

        show_group = self.parse.add_argument_group('Show options')
        show_group.add_argument('-s', '--show', help="Display current connection information", action='store_true')
        self.help = __doc__+self.parse.format_help()

        self._host = 'localhost'
        self._port = 3306
        self._user = None
        self._password = None
        self._current_database = None
        self._last_connect_status = False

    def _upload_lib(self, ret:EvalResult)-> EvalResult:
        '''上传可能缺失动态库
        '''
        if isinstance(self.session.client, CSharpWebshell):
            assems = []
            path = self.session.server_info['tmpdir']+self.session.server_info['sep']+utils.randomstr(8)
            for e in ret.errors:
                if e.errcode == "CS0246" and 'MySql' in e.errmsg:
                    assems.append(path)
                    break
            if path in assems:
                logger.info("Try to upload MySql.Data.dll !")
                if self.session.exec(['upload', os.path.join(os.path.dirname(__file__), 'extra_code', 'MySql.Data.dll'), path]) == self.SUCCESS:
                    assems.extend(self.session.client.options.extra_assemblys)
                    self.session.client.options.set_temp_option('extra_assemblys', str(assems))
                    ret = self.evalfile('payload/connect', host=self._host, port=self._port, user=self._user, 
                        password=self._password, database=self._current_database)
                    self.session.exec(['rm', '-f', path], False) # 删除临时文件

        return ret

    def _connect(self)-> int:
        ret = self.evalfile('payload/connect', host=self._host, port=self._port, user=self._user, 
            password=self._password, database=self._current_database)
        if not ret.is_success():
            ret = self._upload_lib(ret)

        ret = ret.data
        if ret is None:
            logger.error('Connect error!')
            return self.STOP
        ret = json.loads(ret)
        if ret['code'] == -1:
            msg = base64.b64decode(ret['msg'].encode()).decode(self.session.client.options.encoding, 'ignore')
            logger.error('Connect failed!')
            logger.error(msg)
            self._last_connect_status = False
            return self.STOP
        elif ret['code'] == 1:
            logger.info('Connect successfully!', True)
            self._last_connect_status = True
        elif ret['code'] == 0:
            logger.error("Can't find function `mysqli_connect`, the server may not have the Mysqli extension installed.")
            self._last_connect_status = False
            return self.STOP
        return self.SUCCESS

    def _show(self)-> int:
        table = [
            ['Host', self._host],
            ['Port', self._port],
            ['User', self._user],
            ['Password', self._password],
            ['Current database', self._current_database],
            ['Last connection', colour.colorize('Success', 'bold', 'green') if self._last_connect_status else colour.colorize('Failed', 'bold', 'red')]
        ]
        print(tablor(table, False, indent=''))
        return self.SUCCESS

    def _query(self, sql: str)-> int:
        ret = self.evalfile('payload/query', host=self._host, port=self._port, user=self._user, 
            password=self._password, database=self._current_database, sql=sql)
        ret = ret.data
        if ret is None:
            return self.STOP
        ret = json.loads(ret)
        encoding = self.session.client.options.encoding
        if ret['code'] in (0, -1):
            msg = base64.b64decode(ret['msg'].encode()).decode(encoding, 'ignore')
            print(msg)
            if ret['code'] == -1:
                self._last_connect_status = False
                return self.STOP
            return self.ERROR
        elif ret['code'] == 1:
            result = []
            for row in ret['result']:
                tmp = []
                for val in row:
                    val = base64.b64decode(val.encode()).decode(encoding, 'ignore')
                    tmp.append(val)
                result.append(tmp)
            print(tablor(result, indent=' '))
            logger.info(colour.colorize(f"{len(result)-1} rows in set.", 'bold'))
        elif ret['code'] == 2:
            affected = ret['affected']
            logger.info(colour.colorize(f"Query OK, {affected} row affected.", 'bold'))
        elif ret['code'] == -2:
            logger.error("Can't find function `mysqli_connect`, the server may not have the Mysqli extension installed.")
            self._last_connect_status = False
            return self.STOP

        self._last_connect_status = True
        return self.SUCCESS

    def _interactive(self)-> int:
        logger.info("This is just an interactive window that continuously executes SQL statements. ")
        logger.info("Type `exit` or `quit` or Ctrl-C to exit.")
        try:
            while True:
                prompt = colour.colorize('mysql', 'underline')+'('+colour.colorize(f"{self._user}@{self._host}", fore='green')+')'+\
                    f" [{colour.colorize(self._current_database, fore='yellow')}] > "
                sql = utils.input(prompt)
                if sql == '':
                    continue
                elif sql in ('exit', 'quit'):
                    break
                elif sql == 'clear':
                    self.session.exec("clear")
                    continue
                elif sql.startswith('use '):
                    match = re.fullmatch(r'use\s+(\w+)', sql)
                    if match:
                        old = self._current_database
                        self._current_database = match.group(1)
                        if self._query(sql) == self.ERROR:
                            self._current_database = old
                    continue
                self._query(sql)
        except KeyboardInterrupt:
            print('')
        return self.SUCCESS

    def run(self, args: Cmdline)-> int:
        args = self.parse.parse_args(args.options)
        ret = self.SUCCESS
        if args.host:
            self._host = args.host
            if not args.connect:
                logger.info(f"Set host => {args.host}")
        if args.port:
            self._port = args.port
            if not args.connect:
                logger.info(f"Set port => {args.port}")
        if args.user:
            self._user = args.user
            if not args.connect:
                logger.info(f"Set user => {args.user}")
        if args.password:
            self._password = args.password if args.password is not True else None
            if not args.connect:
                logger.info(f"Set password => {self._password}")
        if args.database:
            self._current_database = args.database if args.database is not True else None
            if not args.connect:
                logger.info(f"Set current_database => {self._current_database}")

        if args.connect:
            ret = self._connect()
        elif args.show:
            ret = self._show()
        elif args.interactive:
            ret = self._interactive()
        elif args.sql:
            ret = self._query(args.sql)
        else:
            ret = self._show()

        return ret
    
    def support(self, session:WebshellSession)-> bool:
        '''判断当前命令是否支持指定的session， 一般来说session即为运行改命令时的session
        '''
        self.session = session
        return isinstance(self.session, WebshellSession) and self.session.state['lang'] in (Webshell.PHP, Webshell.ASP_NET_CS, )

    def hook_loaded(self):
        data = self.load_config("mysql-config")
        if data is None:
            return
        self._host = data['host']
        self._port = data['port']
        self._user = data['user']
        self._password = data['pwd']
        self._current_database = data['database']
        
    def hook_destroy(self):
        data = {
            'host':self._host, 
            'port':self._port,
            'user':self._user,
            'pwd':self._password,
            'database':self._current_database
        }
        self.save_config('mysql-config', data)