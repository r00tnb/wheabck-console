r'''Postgresql client.

'''

from api.exploit import WebshellExploit, Cmdline
from api.webshell import WebshellSession, Webshell
from api import Session, utils, logger, tablor, colour
import argparse
import json
import base64
import re

class exploit(WebshellExploit):
    
    def __init__(self):
        super().__init__()
        self.parse = argparse.ArgumentParser(prog='pgsql', description="Postgresql client.", 
            epilog="Before executing the SQL statement, you must first establish a connection.")

        query_group = self.parse.add_argument_group('Query options')
        query_group.add_argument('-i', '--interactive', action='store_true', help="Enter the interactive mode to execute SQL statements continuously")
        query_group.add_argument('sql', nargs='?', default=None, help="A SQL statement.")

        state_group = self.parse.add_argument_group('Set status options')
        state_group.add_argument('-c', "--connect", help="Perform connection test.", action='store_true')
        state_group.add_argument('-H', '--host', help="Specify the host name.")
        state_group.add_argument('-P', '--port', help="Specify the host port.")
        state_group.add_argument('-u', '--user', help="Specify the database user name.")
        state_group.add_argument('-p', '--password', help="Specify the database connection password.")
        state_group.add_argument('-d', '--database', help="Specify the name of the current database.")

        show_group = self.parse.add_argument_group('Show options')
        show_group.add_argument('-s', '--show', help="Display current connection information", action='store_true')
        self.help = __doc__+self.parse.format_help()

        self._host = 'localhost'
        self._port = 5432
        self._user = 'postgres'
        self._password = None
        self._current_database = 'postgres'
        self._last_connect_status = False

    def _connect(self)-> int:
        ret = self.evalfile('payload/connect', host=self._host, port=self._port, user=self._user, 
            password=self._password, database=self._current_database)
        ret = ret.data
        ret = json.loads(ret)
        if ret['code'] == -1:
            msg = base64.b64decode(ret['msg'].encode()).decode(self.session.client.options.encoding, 'ignore')
            logger.error('Connect error!')
            print(msg)
            self._last_connect_status = False
            return self.STOP
        elif ret['code'] == 1:
            logger.info('Connect successfully!', True)
            self._last_connect_status = True
        elif ret['code'] == 0:
            logger.error("Can't find function `pg_connect`, the server may not have the pgsql extension installed.")
            self._last_connect_status = False
            return self.STOP
        return self.SUCCESS

    def _show(self)-> int:
        table = [
            ['Host', self._host],
            ['Port', self._port],
            ['User', self._user],
            ['Password', self._password],
            ['Current database', self._current_database],
            ['Last connection', colour.colorize('Success', 'bold', 'green') if self._last_connect_status else colour.colorize('Failed', 'bold', 'red')]
        ]
        print(tablor(table, False, indent=''))
        return self.SUCCESS

    def _query(self, sql: str)-> int:
        ret = self.evalfile('payload/query', host=self._host, port=self._port, user=self._user, 
            password=self._password, database=self._current_database, sql=sql)
        ret = ret.data
        if ret is None:
            return self.STOP
        ret = json.loads(ret)
        encoding = self.session.client.options.encoding
        if ret['code'] in (0, -1):
            msg = base64.b64decode(ret['msg'].encode()).decode(encoding, 'ignore')
            print(msg)
            if ret['code'] == -1:
                self._last_connect_status = False
                return self.STOP
            return self.ERROR
        elif ret['code'] == 1:
            result = []
            fields = []
            for row in ret['result']:
                if not fields:
                    fields = [base64.b64decode(i.encode()).decode(encoding, 'ignore') for i in row.keys()]
                tmp = []
                for val in row.values():
                    val = base64.b64decode(val.encode()).decode(encoding, 'ignore')
                    tmp.append(val)
                result.append(tmp)
            table = [fields, ]+result
            print(tablor(table, indent=''))
            logger.info(colour.colorize(f"{len(result)} rows in set.", 'bold'))
        elif ret['code'] == 2:
            affected = ret['affected']
            logger.info(colour.colorize(f"Query OK, {affected} row affected.", 'bold'))
        elif ret['code'] == -2:
            logger.error("Can't find function `pg_connect`, the server may not have the pgsql extension installed.")
            self._last_connect_status = False
            return self.STOP

        self._last_connect_status = True
        return self.SUCCESS

    def _interactive(self)-> int:
        logger.info("This is just an interactive window that continuously executes SQL statements. ")
        logger.info("Type `exit` or `quit` or Ctrl-C to exit.")
        try:
            while True:
                prompt = colour.colorize('postgresql', 'underline')+'('+colour.colorize(f"{self._user}@{self._host}", fore='green')+')'+\
                    f" [{colour.colorize(self._current_database, fore='yellow')}] > "
                sql = utils.input(prompt)
                if sql == '':
                    continue
                elif sql in ('exit', 'quit'):
                    break
                elif sql == 'clear':
                    self.session.exec("clear")
                    continue
                elif sql.startswith('use '):
                    match = re.fullmatch(r'use\s+(\w+)', sql)
                    if match:
                        old = self._current_database
                        self._current_database = match.group(1)
                        if self._query(sql) == self.ERROR:
                            self._current_database = old
                    continue
                self._query(sql)
        except KeyboardInterrupt:
            print('')
        return self.SUCCESS

    def run(self, args: Cmdline)-> int:
        args = self.parse.parse_args(args.options)
        ret = self.SUCCESS
        if args.host:
            self._host = args.host
            if not args.connect:
                logger.info(f"Set host => {args.host}")
        if args.port:
            self._port = args.port
            if not args.connect:
                logger.info(f"Set port => {args.port}")
        if args.user:
            self._user = args.user
            if not args.connect:
                logger.info(f"Set user => {args.user}")
        if args.password:
            self._password = args.password
            if not args.connect:
                logger.info(f"Set password => {args.password}")
        if args.database:
            self._current_database = args.database
            if not args.connect:
                logger.info(f"Set current_database => {args.database}")

        if args.connect:
            ret = self._connect()
        elif args.show:
            ret = self._show()
        elif args.interactive:
            ret = self._interactive()
        elif args.sql:
            ret = self._query(args.sql)

        return ret
    
    def support(self, session:WebshellSession)-> bool:
        '''判断当前命令是否支持指定的session， 一般来说session即为运行改命令时的session
        '''
        self.session = session
        return isinstance(self.session, WebshellSession) and self.session.server_info.lang == Webshell.PHP