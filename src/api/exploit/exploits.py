
from src.core.exploit import Exploit
from src.core.webshell import EvalResult
from src.core.session import WebshellSession, Session
from src.core.base import Payload, call_path, WebshellBase
from src.core.payload import PHPPayload, CSharpPayload
from src.logger import logger
import src.config as config
import os
import json
import xml.etree.ElementTree as ET
import traceback
from api import utils

class WebshellExploit(Exploit):
    '''一般来说，运行在webshellsession的命令应该继承该类
    '''
    def __init__(self):
        super().__init__()
        self.session = None
        self.name = self.__class__.__module__

    # def docomplete(self, text: str)-> dict:# 如果提供了该函数，则会使用该函数参与命令补全
    #     '''
    #     Return Format:
    #         {'pre':'', 'matchs':[]}
    #     '''
    #     pass

    def support(self, session: Session)-> bool:
        '''判断当前命令是否支持指定的session， 一般来说session即为运行该命令时的session
        '''
        self.session = session
        return isinstance(self.session, WebshellSession)

    def _payload(self, _____path:str, isstring=False, **kw)->Payload:
        '''根据服务端语言构造payload
        '''
        if not isinstance(self.session, WebshellSession):
            return None
        payload = None
        if self.session.state['lang'] == WebshellBase.PHP:
            payload = PHPPayload(None, **kw)
        elif self.session.state['lang'] == WebshellBase.ASP_NET_CS:
            payload = CSharpPayload(None, **kw)
        else:
            payload = Payload(None, **kw)

        if payload:
            if isstring:
                payload.from_string(_____path)
            else:
                path = os.path.join(os.path.dirname(call_path(2)), _____path)
                try:
                    payload.from_file(path)
                except FileNotFoundError:
                    logger.error(f"Cannot find file `{path}`, maybe the accessed payload is not implemented!")
                    raise SystemExit

        return payload

    def eval(self, code: str, **kw)-> EvalResult:
        '''根据当前webshell session的语言类型执行代码
        '''
        if not isinstance(self.session, WebshellSession):
            return EvalResult()
        payload = self._payload(code, True, **kw)
        if payload is None:
            return EvalResult()
        return self.session.client.eval(payload)

    def evalfile(self, _____path:str, **kw)-> EvalResult:
        '''根据当前webshell session的语言类型执行代码文件, path参数必须是不带后缀的，会根据当前webshell client的语言类型来自动添加后缀
        '''
        if not isinstance(self.session, WebshellSession):
            return EvalResult()
        
        _____path += '.'+self.session.state['lang']
        path = os.path.join(os.path.dirname(call_path(2)), _____path)
        payload = self._payload(path, False, **kw)
        if payload is None:
            return EvalResult()
        return self.session.client.eval(payload)

    def exec_command(self, cmdline: str)-> str:
        '''执行一个系统命令在服务端, 此函数直接调用webshell client的命令执行函数执行命令，它的执行方式会被command_executor选项影响
        '''
        if not isinstance(self.session, WebshellSession):
            return None

        return self.session.client.exec_command(cmdline)

    def save_config(self, name: str, jsondata: object)-> bool:
        '''保存一些信息到当前webshell对应的connections中，如果当前webshell设置了nosave标志（不保存连接信息），则保存不会成功。其中jsondata为序列对象
        '''
        if not isinstance(self.session, WebshellSession):
            return False
        if self.session.state.get('nosave') is not None:
            return False
        if not os.path.exists(config.webshell_save_path):
            return False
        tree = ET.parse(config.webshell_save_path)
        root = tree.getroot()
        ID = self.session.state.get('save_id')
        item = root.find(f"./item[@id='{ID}']")
        if item is None:
            return False
        exploit_config = item.find("./exploit-config")
        if exploit_config is None:
            exploit_config = ET.Element("exploit-config")
            item.append(exploit_config)

        info = exploit_config.find(f"./config[@name='{name}']")
        if info is None:
            info = ET.Element("config", {'name':name})
            exploit_config.append(info)
        
        info.text = json.dumps(jsondata)
        tree.write(config.webshell_save_path)
        return True

    def load_config(self, name: str)-> object:
        '''从当前保存的connections信息中获取指定名称的配置信息，获取失败返回None, 结果是序列对象
        '''
        ret = None
        if not isinstance(self.session, WebshellSession):
            return ret
        if self.session.state.get('nosave') is not None:
            return ret
        if not os.path.exists(config.webshell_save_path):
            return ret
        tree = ET.parse(config.webshell_save_path)
        root = tree.getroot()
        ID = self.session.state.get('save_id')
        info = root.find(f"./item[@id='{ID}']/exploit-config/config[@name='{name}']")
        if info is None:
            return ret
        try:
            ret = json.loads(info.text)
        except:
            pass
        return ret